/*
  @license
<<<<<<< HEAD
	Rollup.js v4.9.0
	Wed, 13 Dec 2023 09:23:48 GMT - commit c5337ef28a71c796e768a9f0edb3d7259a93f1aa
=======
	Rollup.js v2.77.3
	Thu, 11 Aug 2022 05:48:58 GMT - commit 1165d46685ef3c70617b2f150ab245ff5de5e783
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3

	https://github.com/rollup/rollup

	Released under the MIT License.
*/
'use strict';

Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });

<<<<<<< HEAD
const node_path = require('node:path');
const process = require('node:process');
const rollup = require('./rollup.js');
const node_os = require('node:os');
const index = require('./index.js');
require('./parseAst.js');
require('../native.js');
require('tty');
require('path');
require('node:perf_hooks');
require('node:fs/promises');
require('fs');
require('util');
require('stream');
require('os');
require('./fsevents-importer.js');
require('events');
=======
const require$$0 = require('path');
const process = require('process');
const rollup = require('./rollup.js');
const mergeOptions = require('./mergeOptions.js');
const require$$2 = require('os');
const index = require('./index.js');
require('perf_hooks');
require('crypto');
require('fs');
require('events');
require('util');
require('stream');
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3

class FileWatcher {
    constructor(task, chokidarOptions) {
        this.transformWatchers = new Map();
        this.chokidarOptions = chokidarOptions;
        this.task = task;
        this.watcher = this.createWatcher(null);
    }
    close() {
        this.watcher.close();
        for (const watcher of this.transformWatchers.values()) {
            watcher.close();
        }
    }
    unwatch(id) {
        this.watcher.unwatch(id);
        const transformWatcher = this.transformWatchers.get(id);
        if (transformWatcher) {
            this.transformWatchers.delete(id);
            transformWatcher.close();
        }
    }
    watch(id, isTransformDependency) {
<<<<<<< HEAD
        if (isTransformDependency) {
            const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);
=======
        var _a;
        if (isTransformDependency) {
            const watcher = (_a = this.transformWatchers.get(id)) !== null && _a !== void 0 ? _a : this.createWatcher(id);
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
            watcher.add(id);
            this.transformWatchers.set(id, watcher);
        }
        else {
            this.watcher.add(id);
        }
    }
    createWatcher(transformWatcherId) {
        const task = this.task;
<<<<<<< HEAD
        const isLinux = node_os.platform() === 'linux';
=======
        const isLinux = require$$2.platform() === 'linux';
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
        const isTransformDependency = transformWatcherId !== null;
        const handleChange = (id, event) => {
            const changedId = transformWatcherId || id;
            if (isLinux) {
                // unwatching and watching fixes an issue with chokidar where on certain systems,
                // a file that was unlinked and immediately recreated would create a change event
                // but then no longer any further events
                watcher.unwatch(changedId);
                watcher.add(changedId);
            }
            task.invalidate(changedId, { event, isTransformDependency });
        };
        const watcher = index.chokidar
            .watch([], this.chokidarOptions)
            .on('add', id => handleChange(id, 'create'))
            .on('change', id => handleChange(id, 'update'))
            .on('unlink', id => handleChange(id, 'delete'));
        return watcher;
    }
}

const eventsRewrites = {
    create: {
        create: 'buggy',
<<<<<<< HEAD
        delete: null, //delete file from map
=======
        delete: null,
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
        update: 'create'
    },
    delete: {
        create: 'update',
        delete: 'buggy',
        update: 'buggy'
    },
    update: {
        create: 'buggy',
        delete: 'delete',
        update: 'update'
    }
};
class Watcher {
<<<<<<< HEAD
    constructor(optionsList, emitter) {
        this.buildDelay = 0;
        this.buildTimeout = null;
        this.closed = false;
=======
    constructor(configs, emitter) {
        this.buildDelay = 0;
        this.buildTimeout = null;
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
        this.invalidatedIds = new Map();
        this.rerun = false;
        this.running = true;
        this.emitter = emitter;
        emitter.close = this.close.bind(this);
<<<<<<< HEAD
        this.tasks = optionsList.map(options => new Task(this, options));
        for (const { watch } of optionsList) {
            if (watch && typeof watch.buildDelay === 'number') {
                this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);
            }
        }
        process.nextTick(() => this.run());
    }
    async close() {
        if (this.closed)
            return;
        this.closed = true;
=======
        this.tasks = configs.map(config => new Task(this, config));
        this.buildDelay = configs.reduce((buildDelay, { watch }) => watch && typeof watch.buildDelay === 'number'
            ? Math.max(buildDelay, watch.buildDelay)
            : buildDelay, this.buildDelay);
        process.nextTick(() => this.run());
    }
    async close() {
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
        if (this.buildTimeout)
            clearTimeout(this.buildTimeout);
        for (const task of this.tasks) {
            task.close();
        }
<<<<<<< HEAD
        await this.emitter.emit('close');
=======
        await this.emitter.emitAndAwait('close');
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
        this.emitter.removeAllListeners();
    }
    invalidate(file) {
        if (file) {
<<<<<<< HEAD
            const previousEvent = this.invalidatedIds.get(file.id);
            const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;
=======
            const prevEvent = this.invalidatedIds.get(file.id);
            const event = prevEvent ? eventsRewrites[prevEvent][file.event] : file.event;
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
            if (event === 'buggy') {
                //TODO: throws or warn? Currently just ignore, uses new event
                this.invalidatedIds.set(file.id, file.event);
            }
            else if (event === null) {
                this.invalidatedIds.delete(file.id);
            }
            else {
                this.invalidatedIds.set(file.id, event);
            }
        }
        if (this.running) {
            this.rerun = true;
            return;
        }
        if (this.buildTimeout)
            clearTimeout(this.buildTimeout);
        this.buildTimeout = setTimeout(async () => {
            this.buildTimeout = null;
            try {
<<<<<<< HEAD
                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, { event })));
                this.invalidatedIds.clear();
                await this.emitter.emit('restart');
                this.emitter.removeListenersForCurrentRun();
=======
                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emitAndAwait('change', id, { event })));
                this.invalidatedIds.clear();
                this.emitter.emit('restart');
                this.emitter.removeAwaited();
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
                this.run();
            }
            catch (error) {
                this.invalidatedIds.clear();
<<<<<<< HEAD
                await this.emitter.emit('event', {
=======
                this.emitter.emit('event', {
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
                    code: 'ERROR',
                    error,
                    result: null
                });
<<<<<<< HEAD
                await this.emitter.emit('event', {
=======
                this.emitter.emit('event', {
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
                    code: 'END'
                });
            }
        }, this.buildDelay);
    }
    async run() {
        this.running = true;
<<<<<<< HEAD
        await this.emitter.emit('event', {
=======
        this.emitter.emit('event', {
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
            code: 'START'
        });
        for (const task of this.tasks) {
            await task.run();
        }
        this.running = false;
<<<<<<< HEAD
        await this.emitter.emit('event', {
=======
        this.emitter.emit('event', {
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
            code: 'END'
        });
        if (this.rerun) {
            this.rerun = false;
            this.invalidate();
        }
    }
}
class Task {
<<<<<<< HEAD
    constructor(watcher, options) {
=======
    constructor(watcher, config) {
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
        this.cache = { modules: [] };
        this.watchFiles = [];
        this.closed = false;
        this.invalidated = true;
        this.watched = new Set();
        this.watcher = watcher;
<<<<<<< HEAD
        this.options = options;
        this.skipWrite = Boolean(options.watch && options.watch.skipWrite);
        this.outputs = this.options.output;
        this.outputFiles = this.outputs.map(output => {
            if (output.file || output.dir)
                return node_path.resolve(output.file || output.dir);
=======
        this.skipWrite = Boolean(config.watch && config.watch.skipWrite);
        this.options = mergeOptions.mergeOptions(config);
        this.outputs = this.options.output;
        this.outputFiles = this.outputs.map(output => {
            if (output.file || output.dir)
                return require$$0.resolve(output.file || output.dir);
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
            return undefined;
        });
        const watchOptions = this.options.watch || {};
        this.filter = rollup.createFilter(watchOptions.include, watchOptions.exclude);
        this.fileWatcher = new FileWatcher(this, {
            ...watchOptions.chokidar,
            disableGlobbing: true,
            ignoreInitial: true
        });
    }
    close() {
        this.closed = true;
        this.fileWatcher.close();
    }
    invalidate(id, details) {
        this.invalidated = true;
        if (details.isTransformDependency) {
            for (const module of this.cache.modules) {
                if (!module.transformDependencies.includes(id))
                    continue;
                // effective invalidation
                module.originalCode = null;
            }
        }
        this.watcher.invalidate({ event: details.event, id });
    }
    async run() {
        if (!this.invalidated)
            return;
        this.invalidated = false;
        const options = {
            ...this.options,
            cache: this.cache
        };
        const start = Date.now();
<<<<<<< HEAD
        await this.watcher.emitter.emit('event', {
=======
        this.watcher.emitter.emit('event', {
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
            code: 'BUNDLE_START',
            input: this.options.input,
            output: this.outputFiles
        });
        let result = null;
        try {
            result = await rollup.rollupInternal(options, this.watcher.emitter);
            if (this.closed) {
                return;
            }
            this.updateWatchedFiles(result);
<<<<<<< HEAD
            if (!this.skipWrite) {
                await Promise.all(this.outputs.map(output => result.write(output)));
                if (this.closed) {
                    return;
                }
                this.updateWatchedFiles(result);
            }
            await this.watcher.emitter.emit('event', {
=======
            this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));
            this.watcher.emitter.emit('event', {
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
                code: 'BUNDLE_END',
                duration: Date.now() - start,
                input: this.options.input,
                output: this.outputFiles,
                result
            });
        }
        catch (error) {
            if (!this.closed) {
                if (Array.isArray(error.watchFiles)) {
                    for (const id of error.watchFiles) {
                        this.watchFile(id);
                    }
                }
                if (error.id) {
                    this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);
                }
            }
<<<<<<< HEAD
            await this.watcher.emitter.emit('event', {
=======
            this.watcher.emitter.emit('event', {
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
                code: 'ERROR',
                error,
                result
            });
        }
    }
    updateWatchedFiles(result) {
        const previouslyWatched = this.watched;
        this.watched = new Set();
        this.watchFiles = result.watchFiles;
        this.cache = result.cache;
        for (const id of this.watchFiles) {
            this.watchFile(id);
        }
        for (const module of this.cache.modules) {
            for (const depId of module.transformDependencies) {
                this.watchFile(depId, true);
            }
        }
        for (const id of previouslyWatched) {
            if (!this.watched.has(id)) {
                this.fileWatcher.unwatch(id);
            }
        }
    }
    watchFile(id, isTransformDependency = false) {
        if (!this.filter(id))
            return;
        this.watched.add(id);
<<<<<<< HEAD
        if (this.outputFiles.includes(id)) {
=======
        if (this.outputFiles.some(file => file === id)) {
>>>>>>> a4330c92abd799b6367591b02a3005be685f97f3
            throw new Error('Cannot import the generated bundle');
        }
        // this is necessary to ensure that any 'renamed' files
        // continue to be watched following an error
        this.fileWatcher.watch(id, isTransformDependency);
    }
}

exports.Task = Task;
exports.Watcher = Watcher;
//# sourceMappingURL=watch.js.map
